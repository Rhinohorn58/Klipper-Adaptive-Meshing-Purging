# # # Klipper Adaptive Meshing # # #

# Heads up! If you have any other BED_MESH_CALIBRATE macros defined elsewhere in your config, you will need to comment out / remove them for this to work. (Klicky/Euclid Probe)
# You will also need to be sure that [exclude_object] is defined in printer.cfg, and your slicer is labeling objects.
# This macro will parse information from objects in your gcode to define a min and max mesh area to probe, creating an adaptive mesh!
# This macro will not increase probe_count values in your [bed_mesh] config. If you want richer meshes, be sure to increase probe_count. We recommend at least 5,5.

[gcode_macro BED_MESH_CALIBRATE]
rename_existing: _BED_MESH_CALIBRATE
gcode:
    {% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
    {% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}
    {% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}
    {% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}
    {% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}
    {% set verbose_enable = kamp_settings.verbose_enable | abs %}
    {% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}
    {% set attach_macro = kamp_settings.attach_macro | string %}
    {% set detach_macro = kamp_settings.detach_macro | string %}
    {% set mesh_margin = kamp_settings.mesh_margin | float %}
    {% set fuzz_amount = kamp_settings.fuzz_amount | float %}
    {% set small_mesh_threshold = kamp_settings.small_mesh_threshold | float %}
    {% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}
    {% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1) %}
    {% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1) %}
    {% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}
    {% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}
    {% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}
    {% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}

    {% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}
    {% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}
    {% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}
    {% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}
    {% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}

    {% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}
    {% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}
    {% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}
    {% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}

    {% set area_x = adapted_x_max - adapted_x_min %}
    {% set area_y = adapted_y_max - adapted_y_min %}

    {% set points_x = (((area_x) / max_probe_point_distance_x) | round(method='ceil') | int) + 1 %}
    {% set points_y = (((area_y) / max_probe_point_distance_y) | round(method='ceil') | int) + 1 %}

    {% if (([points_x, points_y]|max) > 6) %}
        {% set algorithm = "bicubic" %}
        {% set min_points = 4 %}
    {% else %}
        {% set algorithm = "lagrange" %}
        {% set min_points = 3 %}
    {% endif %}

    # --- Auto 2×2 probing if either dimension is under threshold ---
    {% if area_x < small_mesh_threshold or area_y < small_mesh_threshold %}
        {% set min_points = 2 %}
        {% set algorithm = "lagrange" %}
        {% if verbose_enable == True %}
            { action_respond_info("Small mesh detected: {:.1f}×{:.1f}mm, below {}mm threshold → switching to 2×2 lagrange mesh."
                .format(area_x, area_y, small_mesh_threshold)) }
        {% endif %}
    {% endif %}

    {% set points_x = [points_x , min_points]|max %}
    {% set points_y = [points_y , min_points]|max %}
    {% set points_x = [points_x , probe_count[0]]|min %}
    {% set points_y = [points_y , probe_count[1]]|min %}

    {% if verbose_enable == True %}
        {% if printer.exclude_object.objects != [] %}
            { action_respond_info("Algorithm: {}.".format((algorithm))) }
            { action_respond_info("Default probe count: {},{}.".format((probe_count[0]),(probe_count[1]))) }
            { action_respond_info("Adapted probe count: {},{}.".format((points_x),(points_y))) }
            { action_respond_info("Default mesh bounds: {}, {}.".format((bed_mesh_min[0],bed_mesh_min[1]),(bed_mesh_max[0],bed_mesh_max[1]))) }
            {% if mesh_margin > 0 %}
                { action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format((mesh_margin),(mesh_margin))) }
            {% else %}
                { action_respond_info("Mesh margin is 0, margin not increased.") }
            {% endif %}
            {% if fuzz_amount > 0 %}
                { action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format((fuzz_amount))) }
            {% else %}
                { action_respond_info("Fuzz amount is 0, mesh points not fuzzed.") }
            {% endif %}
            { action_respond_info("Adapted mesh bounds: {}, {}.".format((adapted_x_min, adapted_y_min),(adapted_x_max, adapted_y_max))) }
            { action_respond_info("Small mesh threshold: {}mm.".format((small_mesh_threshold))) }
            { action_respond_info("KAMP adjustments successful. Happy KAMPing!") }
        {% else %}
            { action_respond_info("No objects detected! Defaulting to regular meshing.") }
            G4 P5000
        {% endif %}
    {% endif %}

    {% if probe_dock_enable == True %}
        {attach_macro}
    {% endif %}

    _BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}

    {% if probe_dock_enable == True %}
        {detach_macro}
    {% endif %}
                                                                                                                     # End of verbose
